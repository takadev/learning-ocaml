# OCaml入門

## コメント
(* *)

```
(* コメント *)
```

## 基本の型

 - int      32ビットCPUでは31ビット符号付き整数(およそ±10億)、64ビットCPUでは63ビット符号付き整数
 - float    IEEE倍精度浮動小数点数、Cのdoubleと同じ
 - bool     trueもしくはfalseとなる真偽値
 - char     8bit文字 'a'
 - string   文字列 "foo"
 - unit     ()と書くものCのvoidと似たもの、厳密には違う

## 型変換
OCamlでは暗黙の型変換は一切行われません。

・float_of_int関数
intからfloatへ

・int_of_float関数
floatからintへ

・char_of_int関数
intからcharへ

・int_of_char関数
charからintへ

・string_of_int関数
intからstringへ

・int_of_string関数
stringからintへ


## 四則演算

`+`整数の加算  
`-`整数の減算  
`*`整数の乗算  
`/ `整数の除算  
`mod` 整数除算の剰余  
`+.` 実数の加算  
`-.` 実数の減算  
`*.` 実数の乗算  
`/.` 実数の除算  

```
1 + 2 * 3;;
10 / 2 * 4;;
3.0 +. 2.5;;
5.0 /. 3.0;;
```

## 比較演算子
比較演算子は `=`, `<>`, `<`, `>`, `<=`, `>=`があります。値が等しいかチェックする述語が`=`で、等しくないかチェックする述語が`<>`です。

```
1 = 1;;
1 <> 2;;
1 < 2;;
1 > 2;;
"foo" = "foo";;
```

## 論理演算子
OCamlには`not`, `&&`, `||`という論理演算子があります。

 - not : 否定 (NOT)
 - && : 論理積 (AND)
 - || : 論理和 (OR)

```
1 < 2 && 3 < 4;;
1 < 2 && 3 > 4;;
1 < 2 || 3 > 4;;
not (1 < 2);;
1 < 2 && not (1 > 2);;
```

## 条件分岐
条件分岐はif-then-elseを使います。
if E then F else Gは最初にEを評価して、
結果が真(true)であれば式Fを評価し、
偽(false)であれば式Gを評価します。  
式Fまたは式Gの評価結果がifの返り値になります。
式FとGの返り値はどんな型でもかまいませんが、
同じ型でなければいけません。
型が違うとエラーになります。

```
if 1 < 2 then 3 * 4 else 5 * 6;;
if 1 > 2 then 3 * 4 else 5 * 6;;
```

## 変数宣言
変数(variable)はlet式で宣言します。

```
let 名前 = 式
```

関数型言語の場合、
バインドされた変数は値を書き換えることができません。

```
let a = 10
let b = 2.0
let c = "foo"
```

## 局所変数
局所変数は「有効範囲(スコープ内)」で使用する変数です。
関数の引数が局所変数にあたります。
また、引数以外にも関数内で変数を使用したい場合は局所変数を定義します。

```
let 変数 = 式1 in
```

```
let sum a b c =
  let ab = a + b in
  ab + c;;
```

## 参照

本当の変数が必要なとき、
つまり代入や変数の値を書き換えたい場合は、
参照型を使います。
参照型はrefで生成します。

```
let a = ref 0;;
a := 10;;
!a;;
```

`:=`は、参照に代入する演算子で、
`!`は、参照の内容を取り出す演算子です。


## 関数定義
OCamlは関数もletで定義します。

```
let 名前 引数 = 式
```

letのあとに名前と引数を書き、
=のあとに式を書きます。

```
(* 関数定義 *)
let mul x y = x * y;;
(* 関数呼び出し *)
mul 2 3;;
```

関数型言語の場合、関数もデータ型の一つです。
letで指定したmulは関数型のデータになります。
OCamlは型推論をするので引数や戻り値に型を指定する必要はありません。
戻り値にreturn文も必要なく関数内の最後の式を戻り値とします。
呼び出しの際の括弧や引数の間のカンマも必要ありません。

## 匿名関数
Ocamlは匿名関数も定義できます。

```
fun 引数 -> 式
```

let による関数定義は、匿名関数を用いて表すこともできます。

```
let func = fun 引数 -> 式
```

匿名関数は関数型のデータを生成して返します。
そして、letは変数funcをその値にバインドするだけです。
また、OCamlは匿名関数をそのまま実行することができますし、
関数の引数に匿名関数を渡すこともできます。

```
(fun x -> x * x) 5;;
(fun (x, y) -> x + y) (5, 2);;
func((fun x -> x * x) 5);;
```

## カリー化関数

関数型言語は関数をデータ型の一つとして扱うことができるので、
関数の返り値として関数を返すことができます。
この「関数を返す関数」を使うと、
関数の引数が一つでも複数の引数を処理することができます。
このような関数を「カリー化関数」といいます。

```
fun x -> fun y -> x + y;;
```

この関数は引数を一つだけ与えれば、
関数を返し、引数を2つ与えれば、
それらを加算した結果を返します。
最初の引数を受け取って関数を生成し、
その関数を2番目の引数に適用する、
という動作になります。


## 再帰呼び出し

Ocamlでは再帰関数を定義する場合ははletの後ろに`rec`をつけます。
`rec`がないとエラーになりますのでご注意ください。
階乗を計算する再帰関数です。

```
let rec fact n =
  if n = 0 then 1 else n * fact (n - 1)
```

## 相互再帰

相互再帰とは、関数fooが関数barを呼び出し、
関数barでも関数fooを呼び出すというように、
お互いに再帰呼び出しを行っていることをいいます。
OCamlはコンパイル時に型チェックを行うプログラミング言語なので、
fooからbarを呼び出そうとしても、
barが未定義の場合はコンパイルでエラーになります。
このため、OCamlでは相互再帰を定義する際は
`and`で関数を繋げてやります。

```
let rec f1 a1 = 式1
and f2 a2 =  式2
  ...
and fn an = 式n
```

OCamlの場合、`and`は論理演算子ではありません。
論理演算子には`&&`を使います。

```
let rec foo n =
  if n = 0 then true else bar (n - 1)
and bar n =
  if n = 0 then false else foo (n - 1)
```

## 末尾再帰

再帰定義のなかで、処理の最後で再帰呼び出しを行う場合を
「末尾再帰(tail recursion)」といいます。
MLやLispなどの関数型言語や論理型言語のPrologでは、
プログラムをコンパイルもしくは実行するときに、
末尾再帰を繰り返しに変換する処理系があります。
この機能を「末尾再帰最適化」といいます。
なかには Schemeのように、
言語仕様に末尾再帰最適化を行うことを
明記しているプログラミング言語もあります。

```
(* 階乗末尾再帰 *)
let rec facti (n, a) =
  if n = 0 then a else facti (n - 1, a * n)
```

このプログラムでは引数aの使い方がポイントです。
引数aには計算途中の値が格納されていることがわかります。
このような変数を「累算変数」とか「累算器」といいます。
末尾再帰(繰り返し)は再帰定義に比べると
実行速度やメモリの消費量など効率の点で有利です。

### フィボナッチ関数の例

末尾再帰を使わず普通に再帰関数だと自分自身2回呼び出す、
「二重再帰」になります。

```
(* 二十再帰 *)
let rec fibonacci n =
  if n = 0 || n = 1 then 1
  else fibonacci (n - 1) + fibonacci (n - 2)
```

これを累算変数を使って、
二重再帰を末尾再帰へ変換すると、

```
(* 末尾再帰 *)
let fibonacci n =
  let rec fibo (n, a1, a2) =
    if n = 0 then a1 else fibo (n - 1, a1 + a2, a1)
  in
    fibo (n, 1, 0)
```

このようになり、末尾最適化の恩恵を受けることができます。


## 高階関数

OCamlは関数を他のデータ型と同等に取り扱うことができます。
つまり、関数を変数に代入したり、
引数として渡すことができるのです。
また、値として関数を返すこともできるので、
関数を作る関数を定義することもできます。

```
(* 1乗 *)
let identity x = x

(* 2 乗 *)
let square x = x * x

(* 3 乗 *)
let cube x = x * x * x

let rec sum_of (f, n, m, a) =
  if n > m then a
  else sum_of (f, n + 1, m, a + f n)

sum_of (identity, 1, 10, 0);;
sum_of (square, 1, 10, 0);;
sum_of (cube, 1, 10, 0);;
```

関数`sum_of`の第1引数fに関数を渡すことができます。
渡された関数は、今までと同じ方法で呼び出すことができます。
`a + f n`とすることで、関数fに引数nを渡した結果を
aに加算することができます。


## 組(tuple)
OCamlは複数の型を組み合わせて
新しい型を定義することができます。
OCamlの場合、新しい型の定義方法はいくつかあるのですが、
もっとも簡単で重要な方法が
「組(tuple)」です。
組は複数のデータや式をカンマ(,)で区切り、
カッコ()で囲んで表します。

```
let a = (1, 2)
let b = (10, 20.5)
let c = (1, 2.5, "foo")
let d = (1+2, 3*4)

let (a, b) = (1, 2)
let (a, b) = ((1, 2), 3)
let ((c, d), e) = ((1, 2), 3)
```

## リスト
OCamlのリストは「連結リスト(Linked List)」です。
OCamlのリストは複数のデータを格納することができます。
ただし、リストの要素は同じデータ型でなければいけません。
OCamlのリストは、要素をセミコロン(;)で区切り、
角カッコ[]で囲んで表します。

```
let a = [1; 2; 3; 4]
let b = ["abc"; "def"; "ghi"]
let c = [(1, 2); (3, 4); (5, 6)]
let d = [[1]; [2; 3]; [4; 5; 6]]
let e = [1 + 2 + 3; 4 * 5 * 6]
```

### リストの合成と分解
リストの操作はListモジュールを使用します。
関数`hd`で先頭の要素を取得し、
関数`tl`で先頭要素を取り除いたリストを返します。
演算子`::`(コンス演算子)で合成することができます。
また、演算子`@`でリストを連結することができます。
要素のないリストを「空リスト」といい、
[]で表します。

```
let a = [1; 2; 3; 4];;
List.hd a;;
List.tl a;;
et b = 0 :: a;;
let c = [1; 2; 3] @ [4; 5; 6];;
[];;
```

## パターンマッチ

OCamlは「パターンマッチング(pattern matching)」を使って
条件分岐を行うことができます。
また、リストもパターンマッチングで分解することができます。

### match式

パターンマッチングはmatch式で行います。

```
match 式0 with
  pattern_1 -> 式1
| pattern_2 -> 式2
  ...
| pattern_n -> 式n
```

|で区切られた部分をマッチング節(matching clause)といいます。
match式は式0の評価結果とパターンを照合し、
マッチングする節を選択して実行します。
たとえば、式0の結果とpattern_1がマッチングした場合、
式1を評価してその結果がmatch式の返り値になります。
マッチングしない場合は次のパターンを調べます。
マッチングするパターンが見つからない場合はエラーになります。
なお、一度マッチング節が選択された場合、
それ以降の節は選択されません。
また、式1から式nの結果は同じ型でなければいけません。

```
(* 階乗 *)

(* パターンマッチング未使用 *)
let rec fact n =
  if n = 0 then 1
  else n * fact (n - 1)

(* パターンマッチング *)
let rec fact n =
  match n with
    0 -> 1
  | n' -> n' * fact (n' - 1)
```

パターンが定数の場合、
同じ値の引数とマッチングします。
最初の定義はパターンが0なので、
引数が0の場合にマッチングします。
これはif n = 0 then 1と同じ処理です。
パターンが変数の場合はどんな値とでもマッチングします。
そして、変数はその値に束縛されます。
したがって、nが0以外の場合は2番目のパターンと一致し、
変数n'の値はnになります。ここで再帰呼び出しが行われます。
変数n'はnと同じ値なので、
パターンにワイルドカードを使って次のように定義してもかまいません。

```
| _ -> n * fact (n - 1)
```


