# OCaml入門

## コメント
(* *)

```
(* コメント *)
```

## 基本の型

 - int      32ビットCPUでは31ビット符号付き整数(およそ±10億)、64ビットCPUでは63ビット符号付き整数
 - float    IEEE倍精度浮動小数点数、Cのdoubleと同じ
 - bool     trueもしくはfalseとなる真偽値
 - char     8bit文字 'a'
 - string   文字列 "foo"
 - unit     ()と書くものCのvoidと似たもの、厳密には違う

## 型変換
OCamlでは暗黙の型変換は一切行われません。

・float_of_int関数
intからfloatへ

・int_of_float関数
floatからintへ

・char_of_int関数
intからcharへ

・int_of_char関数
charからintへ

・string_of_int関数
intからstringへ

・int_of_string関数
stringからintへ


## 四則演算

`+`整数の加算  
`-`整数の減算  
`*`整数の乗算  
`/ `整数の除算  
`mod` 整数除算の剰余  
`+.` 実数の加算  
`-.` 実数の減算  
`*.` 実数の乗算  
`/.` 実数の除算  

```
1 + 2 * 3;;
10 / 2 * 4;;
3.0 +. 2.5;;
5.0 /. 3.0;;
```

## 比較演算子
比較演算子は `=`, `<>`, `<`, `>`, `<=`, `>=`があります。値が等しいかチェックする述語が`=`で、等しくないかチェックする述語が`<>`です。

```
1 = 1;;
1 <> 2;;
1 < 2;;
1 > 2;;
"foo" = "foo";;
```

## 論理演算子
OCamlには`not`, `&&`, `||`という論理演算子があります。

 - not : 否定 (NOT)
 - && : 論理積 (AND)
 - || : 論理和 (OR)

```
1 < 2 && 3 < 4;;
1 < 2 && 3 > 4;;
1 < 2 || 3 > 4;;
not (1 < 2);;
1 < 2 && not (1 > 2);;
```

## 条件分岐
条件分岐はif-then-elseを使います。
if E then F else Gは最初にEを評価して、
結果が真(true)であれば式Fを評価し、
偽(false)であれば式Gを評価します。  
式Fまたは式Gの評価結果がifの返り値になります。
式FとGの返り値はどんな型でもかまいませんが、
同じ型でなければいけません。
型が違うとエラーになります。

```
if 1 < 2 then 3 * 4 else 5 * 6;;
if 1 > 2 then 3 * 4 else 5 * 6;;
```

## 変数宣言
変数(variable)はlet式で宣言します。

```
let 名前 = 式
```

関数型言語の場合、
バインドされた変数は値を書き換えることができません。

```
let a = 10
let b = 2.0
let c = "foo"
```

## 局所変数
局所変数は「有効範囲(スコープ内)」で使用する変数です。
関数の引数が局所変数にあたります。
また、引数以外にも関数内で変数を使用したい場合は局所変数を定義します。

```
let 変数 = 式1 in
```

```
let sum a b c =
  let ab = a + b in
  ab + c;;
```

## 参照

本当の変数が必要なとき、
つまり代入や変数の値を書き換えたい場合は、
参照型を使います。
参照型はrefで生成します。

```
let a = ref 0;;
a := 10;;
!a;;
```

`:=`は、参照に代入する演算子で、
`!`は、参照の内容を取り出す演算子です。


## 関数定義
OCamlは関数もletで定義します。

```
let 名前 引数 = 式
```

letのあとに名前と引数を書き、
=のあとに式を書きます。

```
(* 関数定義 *)
let mul x y = x * y;;
(* 関数呼び出し *)
mul 2 3;;
```

関数型言語の場合、関数もデータ型の一つです。
letで指定したmulは関数型のデータになります。
OCamlは型推論をするので引数や戻り値に型を指定する必要はありません。
戻り値にreturn文も必要なく関数内の最後の式を戻り値とします。
呼び出しの際の括弧や引数の間のカンマも必要ありません。

## 匿名関数
Ocamlは匿名関数も定義できます。

```
fun 引数 -> 式
```

let による関数定義は、匿名関数を用いて表すこともできます。

```
let func = fun 引数 -> 式
```

匿名関数は関数型のデータを生成して返します。
そして、letは変数funcをその値にバインドするだけです。
また、OCamlは匿名関数をそのまま実行することができますし、
関数の引数に匿名関数を渡すこともできます。

```
(fun x -> x * x) 5;;
(fun (x, y) -> x + y) (5, 2);;
func((fun x -> x * x) 5);;
```

## カリー化関数

関数型言語は関数をデータ型の一つとして扱うことができるので、
関数の返り値として関数を返すことができます。
この「関数を返す関数」を使うと、
関数の引数が一つでも複数の引数を処理することができます。
このような関数を「カリー化関数」といいます。

```
fun x -> fun y -> x + y;;
```

この関数は引数を一つだけ与えれば、
関数を返し、引数を2つ与えれば、
それらを加算した結果を返します。
最初の引数を受け取って関数を生成し、
その関数を2番目の引数に適用する、
という動作になります。


## 再帰呼び出し

Ocamlでは再帰関数を定義する場合ははletの後ろに`rec`をつけます。
`rec`がないとエラーになりますのでご注意ください。
階乗を計算する再帰関数です。

```
let rec fact n =
  if n = 0 then 1 else n * fact (n - 1)
```

## 相互再帰

相互再帰とは、関数fooが関数barを呼び出し、
関数barでも関数fooを呼び出すというように、
お互いに再帰呼び出しを行っていることをいいます。
OCamlはコンパイル時に型チェックを行うプログラミング言語なので、
fooからbarを呼び出そうとしても、
barが未定義の場合はコンパイルでエラーになります。
このため、OCamlでは相互再帰を定義する際は
`and`で関数を繋げてやります。

```
let rec f1 a1 = 式1
and f2 a2 =  式2
  ...
and fn an = 式n
```

OCamlの場合、`and`は論理演算子ではありません。
論理演算子には`&&`を使います。

```
let rec foo n =
  if n = 0 then true else bar (n - 1)
and bar n =
  if n = 0 then false else foo (n - 1)
```

## 末尾再帰

再帰定義のなかで、処理の最後で再帰呼び出しを行う場合を
「末尾再帰(tail recursion)」といいます。
MLやLispなどの関数型言語や論理型言語のPrologでは、
プログラムをコンパイルもしくは実行するときに、
末尾再帰を繰り返しに変換する処理系があります。
この機能を「末尾再帰最適化」といいます。
なかには Schemeのように、
言語仕様に末尾再帰最適化を行うことを
明記しているプログラミング言語もあります。

```
(* 階乗末尾再帰 *)
let rec facti (n, a) =
  if n = 0 then a else facti (n - 1, a * n)
```

このプログラムでは引数aの使い方がポイントです。
引数aには計算途中の値が格納されていることがわかります。
このような変数を「累算変数」とか「累算器」といいます。
末尾再帰(繰り返し)は再帰定義に比べると
実行速度やメモリの消費量など効率の点で有利です。

### フィボナッチ関数の例

末尾再帰を使わず普通に再帰関数だと自分自身2回呼び出す、
「二重再帰」になります。

```
(* 二十再帰 *)
let rec fibonacci n =
  if n = 0 || n = 1 then 1
  else fibonacci (n - 1) + fibonacci (n - 2)
```

これを累算変数を使って、
二重再帰を末尾再帰へ変換すると、

```
(* 末尾再帰 *)
let fibonacci n =
  let rec fibo (n, a1, a2) =
    if n = 0 then a1 else fibo (n - 1, a1 + a2, a1)
  in
    fibo (n, 1, 0)
```

このようになり、末尾最適化の恩恵を受けることができます。


## 高階関数

OCamlは関数を他のデータ型と同等に取り扱うことができます。
つまり、関数を変数に代入したり、
引数として渡すことができるのです。
また、値として関数を返すこともできるので、
関数を作る関数を定義することもできます。

```
(* 1乗 *)
let identity x = x

(* 2 乗 *)
let square x = x * x

(* 3 乗 *)
let cube x = x * x * x

let rec sum_of (f, n, m, a) =
  if n > m then a
  else sum_of (f, n + 1, m, a + f n)

sum_of (identity, 1, 10, 0);;
sum_of (square, 1, 10, 0);;
sum_of (cube, 1, 10, 0);;
```

関数`sum_of`の第1引数fに関数を渡すことができます。
渡された関数は、今までと同じ方法で呼び出すことができます。
`a + f n`とすることで、関数fに引数nを渡した結果を
aに加算することができます。


## 組(tuple)
OCamlは複数の型を組み合わせて
新しい型を定義することができます。
OCamlの場合、新しい型の定義方法はいくつかあるのですが、
もっとも簡単で重要な方法が
「組(tuple)」です。
組は複数のデータや式をカンマ(,)で区切り、
カッコ()で囲んで表します。

```
let a = (1, 2)
let b = (10, 20.5)
let c = (1, 2.5, "foo")
let d = (1+2, 3*4)

let (a, b) = (1, 2)
let (a, b) = ((1, 2), 3)
let ((c, d), e) = ((1, 2), 3)
```

## リスト
OCamlのリストは「連結リスト(Linked List)」です。
OCamlのリストは複数のデータを格納することができます。
ただし、リストの要素は同じデータ型でなければいけません。
OCamlのリストは、要素をセミコロン(;)で区切り、
角カッコ[]で囲んで表します。

```
let a = [1; 2; 3; 4]
let b = ["abc"; "def"; "ghi"]
let c = [(1, 2); (3, 4); (5, 6)]
let d = [[1]; [2; 3]; [4; 5; 6]]
let e = [1 + 2 + 3; 4 * 5 * 6]
```

### リストの合成と分解
リストの操作はListモジュールを使用します。
関数`hd`で先頭の要素を取得し、
関数`tl`で先頭要素を取り除いたリストを返します。
演算子`::`(コンス演算子)で合成することができます。
また、演算子`@`でリストを連結することができます。
要素のないリストを「空リスト」といい、
[]で表します。

```
let a = [1; 2; 3; 4];;
List.hd a;;
List.tl a;;
et b = 0 :: a;;
let c = [1; 2; 3] @ [4; 5; 6];;
[];;
```

## パターンマッチ

OCamlは「パターンマッチング(pattern matching)」を使って
条件分岐を行うことができます。
また、リストもパターンマッチングで分解することができます。

### match式

パターンマッチングはmatch式で行います。

```
match 式0 with
  pattern_1 -> 式1
| pattern_2 -> 式2
  ...
| pattern_n -> 式n
```

|で区切られた部分をマッチング節(matching clause)といいます。
match式は式0の評価結果とパターンを照合し、
マッチングする節を選択して実行します。
たとえば、式0の結果とpattern_1がマッチングした場合、
式1を評価してその結果がmatch式の返り値になります。
マッチングしない場合は次のパターンを調べます。
マッチングするパターンが見つからない場合はエラーになります。
なお、一度マッチング節が選択された場合、
それ以降の節は選択されません。
また、式1から式nの結果は同じ型でなければいけません。

```
(* 階乗 *)

(* パターンマッチング未使用 *)
let rec fact n =
  if n = 0 then 1
  else n * fact (n - 1)

(* パターンマッチング *)
let rec fact n =
  match n with
    0 -> 1
  | n' -> n' * fact (n' - 1)

(* パターンマッチング末尾再帰 *)
let fact1 n =
  let rec fact2(n, a) =
    match n with
      0 -> a
      | n -> fact2(n - 1, a * n)
    in
      fact2(n, 1);;
```

パターンが定数の場合、
同じ値の引数とマッチングします。
最初の定義はパターンが0なので、
引数が0の場合にマッチングします。
これはif n = 0 then 1と同じ処理です。
パターンが変数の場合はどんな値とでもマッチングします。
そして、変数はその値に束縛されます。
したがって、nが0以外の場合は2番目のパターンと一致し、
変数n'の値はnになります。ここで再帰呼び出しが行われます。
変数n'はnと同じ値なので、
パターンにワイルドカードを使って
次のように定義してもかまいません。

```
| _ -> n * fact (n - 1)
```

### function文

match式によるパターンマッチングは
function文を使うと簡単になります。
function文は匿名関数とmatch式を組み合わせたものです。

```
function
  pattern_1 -> 式1
| pattern_2 -> 式2
  ...
| pattern_n -> 式n
```

```
(* 階乗 *)
let rec fact = function
  0 -> 1
| n -> n * fact (n - 1)
```

### リストのパターンマッチング

リストの操作は関数hd, tlでリストを分解するよりも
「パターンマッチング」を使った方が簡単です。
リストもパターンとマッチングすることができます。
リストのパターンはコンス演算子::を使って表します。

```
(* リストの連結 *)
let rec append xs ys =
  match xs with
    [] -> ys
    | x :: xs -> x :: (append xs ys)
```

最初のパターンは、xsが[]とマッチングします。
次のx :: xsがパターンを表します。
このパターンはリストとマッチングして、
先頭の要素がxに、先頭要素を取り除いた残りのリストが
xsに束縛されます。
このように、関数hdやtlを使わなくてもリストを分解することができます。

リストを表すパターンは x::xs だけではありません。
よく使われるパターンを次に示します。

```
(1) [x]         要素が1つのリストとマッチング
(2) [x; y]      要素が2つのリストとマッチング
(3) x::xs       要素が1つ以上あるリストとマッチング
(4) x1::x2::xs  要素が2つ以上あるリストとマッチング
(5) x1::x1::xs  エラー
```

(5)のように、パターンの中に
同名の変数を使うことはできません。
この場合、x1::x2::xsとマッチングさせてから
x1とx2が等しいかチェックします。
このような場合、キーワード`when`を使うと便利です。

```
パターン when 条件式 -> 式
```

このようなマッチング節を
「ガード付き節」といいます。
パターンとの照合に成功して、
かつ`when`の条件式が真を返す場合に限り
式が評価されます。たとえば、
`when`を使って(5)を実現すると次のようになります。

```
| x1::x2::xs when x1 = x2 -> 式1
| x1::x2::xs when x1 < x2 -> 式2
| x1::x2::xs -> 式3
```

パターンとの照合に成功して、
x1 = x2 の場合は式1が評価されます。
x1 < x2 の場合は式2が評価され、
それ以外の場合は式3が評価されます。

また、もっと複雑なリストもパターンで表すことができます。

```
(* リストの長さ *)
let rec length = function
  [] -> 0
| x :: xs -> 1 + length xs

(* リストの反転 *)
let rec reverse = function
  [] -> []
| x :: xs -> reverse xs @ [x]

(* 探索 *)
let rec member x = function
  [] -> []
| (y :: ys) as xs when x = y -> xs
| (y :: ys) -> member x ys
```

ここで、関数memberを見てください。
パターン y :: ys を使うと
リストを分解することができますが、
分解した値yやysだけではなく、
元のリストの値を参照したいときがあります。
このような場合、`as`を使うと
変数とパターンを同時に設定することができます。

```
パターン as 変数名
```

たとえば、(y :: ys) as xs と
[1; 2; 3] をマッチングさせると、
次のようになります。

```
xs => [1; 2; 3]
y  => 1
ys => [2; 3]
```

このように、
パターン y :: ys とマッチングした場合、
変数 xs の値は分解する前の [1; 2; 3] になります。


### マッピング

リストの要素に関数fを適用して、
その結果をリストに格納して返す操作を
「マッピング（写像）」といいます。

```
let rec mapcar f = function
  [] -> []
| x :: xs -> f x :: mapcar f xs
```

OCamlには同じ機能を持つ関数List.mapがあります。
プログラムは簡単です。
パターンマッチングで引数のリストを先頭の要素xと残りのリストxsに分解します。
そして、xに関数fを適用した結果とmapcar f xsの結果を
コンス演算子::で結合します。
引数のリストが空リストの場合が再帰呼び出しの停止条件になります。

mapcar を定義すると、次のように表示されます。

```
val mapcar = ('a -> 'b) -> 'a list -> 'b list = <fun>
```

第1引数が関数型'a -> 'bで
第2引数がリスト'a listになります。
関数fはリストの要素を受け取るので、
関数fの引数の型とリストの型は一致します。
これを型変数'aで表しています。
同様に、関数fの返り値の型とmapcarの返り値のリストの型は一致します。
これを型変数'bで表しています。
このように、mapcarは多相型関数として定義されます。

```
# mapcar (fun x -> x * x) [1; 2; 3; 4; 5];;
- : int list = [1; 4; 9; 16; 25]
```

## フィルター

フィルター(filter)はリストの要素に関数を適用し、
関数が真を返す要素をリストに格納して返す関数です。
真または偽を返す関数のことを「述語(predicate)」といいます。
ここでは簡単な例題として、
述語が真を返す要素を削除する関数
remove_ifを作ってみましょう。

```
let rec remove_if f = function
  [] -> []
| x :: xs -> if f x then remove_if f xs else x :: remove_if f xs
```

f x が真ならばxをリストに加えません。
偽ならばxをリストに加えるだけです。
remove_if を定義すると次のようになります。

```
val remove_if = ('a -> bool) -> 'a list -> 'a list = <fun>
```

関数fがifの条件式で使われているので、
OCamlは関数fの型を'a -> boolと推論しています。
もちろん、remove_ifも多相型関数として定義されます。
OCamlの型推論はとても便利ですね。

```
# remove_if (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5];;
- : int list = [1; 3; 5]
# remove_if (fun x -> x = "abc") ["abc"; "def"; "abc"; "ghi"];;
- : string list = ["def"; "ghi"]
```

最初の例では偶数の要素が削除されます。
次の例は文字列 "abc" が削除されます。

もちろん、フィルターも簡単に定義することができます。
remove_ifとは逆に、述語が真を返すとき要素をリストに追加し、
偽を返すときはリストに加えません。
なお、OCamlには同様の動作を行う関数List.filterがあります。

```
let rec filter f = function
  [] -> []
| x :: xs -> if f x then x :: filter f xs else filter f xs
```

簡単な実行例を示しましょう。

```
# filter (fun x -> x mod 2 = 0) [1;2;3;4;5];;
- : int list = [2; 4]
```

